<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Multiplayer Chess</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background: #f0f0f0; }
        #board { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); 
                 margin: 20px auto; border: 2px solid #333; background: #fff; }
        .square { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; 
                  font-size: 40px; cursor: pointer; user-select: none; }
        .light { background: #f0d9b5; }
        .dark { background: #b58863; }
        .selected { background: #ffff99 !important; }
        .valid-move { background: #99ff99 !important; }
        .capture-move { background: #ff9999 !important; }
        #status { font-size: 18px; margin: 10px; color: #333; }
        #log { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; text-align: left; margin: 10px auto; width: 500px; background: #fff; }
        input, button { margin: 5px; padding: 10px; font-size: 16px; }
        #roomInput { display: none; }
    </style>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <h1>Online Multiplayer Chess</h1>
    <div>
        <label>Player Color: <span id="playerColor">White</span></label>
        <button id="createRoom">Create Room</button>
        <div id="roomInput">
            <input type="text" id="roomName" placeholder="Enter room name (e.g., room1)" maxlength="20">
            <button id="joinRoom">Join Room</button>
        </div>
    </div>
    <div id="board"></div>
    <div id="status">White to move</div>
    <div id="log">Move log:<br></div>

    <script>
        // Chess Logic
        const SOCKET = io('http://localhost:3000'); // Update to your server URL for production
        let board = [], selected = null, currentPlayer = 'white', playerColor = 'white', room = null;
        const pieces = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        // Initial board setup (FEN-like: rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR)
        function initBoard() {
            const initial = [
                'rnbqkbnr', 'pppppppp', '8', '8', '8', '8', 'PPPPPPPP', 'RNBQKBNR'
            ];
            board = [];
            for (let row = 0; row < 8; row++) {
                board[row] = [];
                const fenRow = initial[7 - row]; // Flip for white at bottom
                for (let col = 0; col < 8; col++) {
                    const char = fenRow[col];
                    if (char === '8' || char === ' ') board[row][col] = null;
                    else if (char === 'P') board[row][col] = { type: 'P', color: 'white' };
                    else if (/[KQRBN]/.test(char)) board[row][col] = { type: char, color: 'white' };
                    else if (/[kqrbn]/.test(char)) board[row][col] = { type: char.toUpperCase(), color: 'black' };
                    else if (char === 'p') board[row][col] = { type: 'P', color: 'black' };
                }
            }
            renderBoard();
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    const piece = board[row][col];
                    if (piece) square.innerHTML = pieces[piece.color === 'white' ? piece.type : piece.type.toLowerCase()];
                    square.addEventListener('click', onSquareClick);
                    boardEl.appendChild(square);
                }
            }
            // Flip board for black player
            if (playerColor === 'black') {
                boardEl.style.transform = 'scaleX(-1) scaleY(-1)'; // Mirror for black's view
            }
        }

        function onSquareClick(e) {
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const piece = board[row][col];

            if (selected) {
                if (isValidMove(selected.row, selected.col, row, col)) {
                    makeMove(selected.row, selected.col, row, col);
                    selected = null;
                    updateHighlights();
                    SOCKET.emit('move', { room, from: {row: selected.row, col: selected.col}, to: {row, col} });
                } else {
                    selected = piece && piece.color === currentPlayer ? { row, col } : null;
                    updateHighlights();
                }
            } else {
                selected = piece && piece.color === currentPlayer ? { row, col } : null;
                updateHighlights();
            }
        }

        function updateHighlights() {
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'valid-move', 'capture-move');
                const row = parseInt(sq.dataset.row), col = parseInt(sq.dataset.col);
                if (selected && row === selected.row && col === selected.col) sq.classList.add('selected');
                else if (selected && isValidMove(selected.row, selected.col, row, col)) {
                    sq.classList.add(board[row][col] ? 'capture-move' : 'valid-move');
                }
            });
        }

        // Basic move validation (simplified; expand for full rules)
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece || piece.color !== currentPlayer) return false;
            const target = board[toRow][toCol];
            if (target && target.color === currentPlayer) return false;

            const deltaRow = toRow - fromRow, deltaCol = toCol - fromCol;
            const absDR = Math.abs(deltaRow), absDC = Math.abs(deltaCol);

            switch (piece.type) {
                case 'P': // Pawn
                    const dir = piece.color === 'white' ? -1 : 1;
                    const startRow = piece.color === 'white' ? 6 : 1;
                    if (deltaCol === 0) { // Forward
                        if (target) return false;
                        if (deltaRow === dir && (fromRow !== startRow || deltaRow !== 2 * dir)) return true;
                        if (fromRow === startRow && deltaRow === 2 * dir && !board[fromRow + dir][fromCol]) return true;
                    } else if (absDC === 1 && deltaRow === dir) { // Capture
                        return target && target.color !== piece.color;
                    }
                    return false;
                case 'R': // Rook
                    if (deltaRow === 0 || deltaCol === 0) return isPathClear(fromRow, fromCol, toRow, toCol);
                    return false;
                case 'N': // Knight
                    return (absDR === 2 && absDC === 1) || (absDR === 1 && absDC === 2);
                case 'B': // Bishop
                    if (absDR === absDC) return isPathClear(fromRow, fromCol, toRow, toCol);
                    return false;
                case 'Q': // Queen
                    if (deltaRow === 0 || deltaCol === 0 || absDR === absDC) return isPathClear(fromRow, fromCol, toRow, toCol);
                    return false;
                case 'K': // King (basic; add castling later)
                    return absDR <= 1 && absDC <= 1;
                default: return false;
            }
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const deltaRow = toRow > fromRow ? 1 : (toRow < fromRow ? -1 : 0);
            const deltaCol = toCol > fromCol ? 1 : (toCol < fromCol ? -1 : 0);
            let r = fromRow + deltaRow, c = fromCol + deltaCol;
            while (r !== toRow || c !== toCol) {
                if (board[r][c]) return false;
                r += deltaRow; c += deltaCol;
            }
            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            // Pawn promotion (simple: to queen)
            if (piece.type === 'P' && (toRow === 0 || toRow === 7)) piece.type = 'Q';
            // Check for check/checkmate (simplified: just update status)
            const inCheck = isInCheck(currentPlayer);
            const statusEl = document.getElementById('status');
            statusEl.textContent = (inCheck ? 'Check! ' : '') + (currentPlayer === 'white' ? 'Black' : 'White') + ' to move';
            if (isCheckmate(currentPlayer)) statusEl.textContent += ' - Checkmate! ' + (currentPlayer === 'white' ? 'Black' : 'White') + ' wins!';
            addToLog(`${piece.type}${String.fromCharCode(97 + fromCol)}${8 - fromRow} to ${String.fromCharCode(97 + toCol)}${8 - toRow}`);
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            renderBoard();
        }

        function isInCheck(color) {
            // Find king position and check if any opponent piece can attack it
            let kingRow, kingCol;
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                if (board[r][c]?.type === 'K' && board[r][c].color === color) { kingRow = r; kingCol = c; }
            }
            // Simplified: check if any opponent piece can move to king
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                const p = board[r][c];
                if (p && p.color !== color && isValidMove(r, c, kingRow, kingCol)) return true;
            }
            return false;
        }

        function isCheckmate(color) {
            if (!isInCheck(color)) return false;
            // Check if any move can escape check (brute force; inefficient but works for basic)
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                const p = board[r][c];
                if (p?.color === color) {
                    for (let tr = 0; tr < 8; tr++) for (let tc = 0; tc < 8; tc++) {
                        if (isValidMove(r, c, tr, tc)) {
                            // Simulate move and check if still in check
                            const temp = board[tr][tc]; board[tr][tc] = p; board[r][c] = null;
                            const stillCheck = isInCheck(color);
                            board[r][c] = p; board[tr][tc] = temp;
                            if (!stillCheck) return false;
                        }
                    }
                }
            }
            return true;
        }

        function addToLog(move) {
            document.getElementById('log').innerHTML += move + '<br>';
        }

        // Socket.io Events
        SOCKET.on('connect', () => console.log('Connected to server'));
        SOCKET.on('joined', (data) => {
            room = data.room;
            playerColor = data.color;
            document.getElementById('playerColor').textContent = playerColor.charAt(0).toUpperCase() + playerColor.slice(1);
            document.getElementById('roomInput').style.display = 'none';
            document.getElementById('status').textContent = `Joined room ${room} as ${playerColor}. ${playerColor === 'white' ? 'You start!' : 'Opponent starts.'}`;
            if (playerColor === 'black') currentPlayer = 'white'; // Black waits
            initBoard();
        });
        SOCKET.on('move', (data) => {
            if (data.room === room) {
                makeMove(data.from.row, data.from.col, data.to.row, data.to.col);
                // Flip currentPlayer after opponent's move
                currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            }
        });
        SOCKET.on('error', (msg) => alert('Error: ' + msg));

        // UI Events
        document.getElementById('createRoom').addEventListener('click', () => {
            room = prompt('Enter room name:');
            if (room) {
                SOCKET.emit('create', { room });
                playerColor = 'white';
                document.getElementById('playerColor').textContent = 'White';
                document.getElementById('createRoom').style.display = 'none';
                document.getElementById('roomInput').style.display = 'block';
                document.getElementById('roomName').placeholder = `Room ${room} created. Share this name.`;
                document.getElementById('joinRoom').textContent = 'Start Game';
            }
        });
        document.getElementById('joinRoom').addEventListener('click', () => {
            const roomName = document.getElementById('roomName').value.trim();
            if (roomName) {
                SOCKET.emit('join', { room: roomName });
            }
        });

        // Init
        initBoard();
    </script>
</body>
</html>
